# promise, async, await
## 콜백
- 인자로 넘겨져 나중에 호출되는(callback) 함수
- 첫 번째 인자는 에러를 위해 사용되는게 관례
```js
asyncFunction(ayncArg, function(error, ...arg) {
  if (error) {
    // 에러 처리
  } 
  else {
    // 대충 콜백으로 실행될 내용들
  }
});
```
### pyramid of doom(callback hell)
- 콜백 기반 비동기 처리를 위해 계속해서 콜백을 타고타고 들어가 관리가 어려워짐
![callback_hell](https://ko.javascript.info/article/callbacks/callback-hell.svg)
- 각 동작을 동립적인 함수로 만들어 해결해도 되지만 가독성도 안좋고 재사용도 어려움
```js
loadScript('1.js', step1);

function step1(error, script) {
  if (error) {
    handleError(error);
  } else {
    // ...
    loadScript('2.js', step2);
  }
}

function step2(error, script) {
  if (error) {
    handleError(error);
  } else {
    // ...
    loadScript('3.js', step3);
  }
}

function step3(error, script) {
  if (error) {
    handleError(error);
  } else {
    // 모든 스크립트가 로딩되면 수행
  }
};
```

## Promise
- `new Promise`에 인자로 넘어가는 함수를 executor라고 함
- `new Promise`생성자가 반환하는 객체에는 `state`, `result` property가 있음
![상태](https://ko.javascript.info/article/promise-chaining/promise-handler-variants.svg)
```js
new Promise((resolve, reject) => {
  ...
})
  .finally(() => alert("결과는 finally를 그냥 통과해서 전달됨"))
  .then(result => alert(result))    // result 처리
  .catch(err => alert(err)) // err 처리
  .then(someFunction, errorHandler) // then에서도 2번째 인자로 에러처리 가능함
  .finally(() => alert("보편적인 일을 하자"))
```
- `then`에서의 2번째 인자로 받는 에러처리는 해당 `then`에서 발생하는 에러(예: `someFunction`에서 에러)는 처리할 수 없음
- `finally`는 promise 성공/실패 여부 상관없이 진행되며 핸들러에는 인수도 없음
- 위 예제의 체이닝이 가능한 건 `result`, `error`을 전달하면서 promise 다시 반환하기 때문.
    - `.then(handler)`에서 `handler`함수가 promise를 다시 반환할 수도 있다.(resolve 함수 호출)
    - `handler`함수는 promise와 호환 가능한 `thenable`객체(`then`메소드 보유)를 반환 할 수도
        ```JS
            // Promise를 상속받지 않은 커스텀 Thenable 클래스
            class Thenable {
                constructor(num) {
                    this.num = num;
                }
                then(resolve, reject) {
                    alert(resolve); // function() { 네이티브 코드 }
                    setTimeout(() => resolve(this.num * 2), 1000); // (**)
                }
            }

            new Promise(resolve => resolve(1))
            .then(result => {
                return new Thenable(result); // (*)
            })
            .then(alert); // 1초 후 2를 보여줌
        ```
## promise 에러 핸들링
- `rejection` -> 제일 가까운 `rejection` 핸들러로 넘어감
- 에러를 `throw`로 날려도 `rejection`으로 봄
```js
fetch('https://no-such-server.blabla') // 실패 발생
  .then(...)
  .then(response => response.json())
  .catch(...) // 에러처리
  .then(...) // catch에서 에러 잘처리했으면 실행
  .catch(...) // 위에서 에러처리 다 안되고 다시 던지면 실행
```
- 에러는 있는데 `then`만 주구장창 체인걸어두고 `catch` 안잡아두면 js엔진은 promise rejection 추적하다가 전역 에러 생성
    - unhandledrejection 이벤트로 잡을 수 있음(HTML 명세서에 정의된 표준)
        ```js
        window.addEventListener('unhandledrejection', function(event) {
        // 이벤트엔 두 개의 특별 프로퍼티 보유
        alert(event.promise); // [object Promise] - 에러를 생성하는 프라미스
        alert(event.reason); // Error: 에러 발생! - 처리하지 못한 에러 객체
        });

        new Promise(function() {
        throw new Error("에러 발생!");
        }); // 에러 처리 핸들러, catch가 없음
        ```
    - 보통 이런 에러는 회복이 어렵기 때문에 걍 사용자에게 문제를 알리고 서버로 에러정보 보냄
- `catch`는 비동기적 에러를 못잡아낸다. 아래 케이스 죄다 못잡음;
    ```js
    new Promise(function(resolve, reject) {
        setTimeout(() => {
            throw new Error("에러 발생!");
        }, 1000);
    }).catch(alert);

    new Promise(function(resolve, reject) { resolve(1) })
        .then((result) => {
            console.log(result)
            setTimeout(() => {
            throw new Error("에러 발생!");
            }, 1000);
        })
        .catch(alert);
    ```