# 네트워크 요청
## fetch
```js
let promise = fetch(url, [options])
```
- 구식 브라우저에선 폴리필 필요
- response header 받으면 promise 반환
    - built-in 클래스 [Response](https://fetch.spec.whatwg.org/#response-class)가 resolve됨.
    - 헤더로 성공/실패는 체크 가능한데 response body는 아직 확인 못함
        - HTTP status code를 나타내는 `status`, status code가 200~299면 `true`인 `ok` property가 있음
    - response header는 걍 `response.headers`로 접근 가능하고 `get`메소드를 써서 'Content-Type'같은거 확인하고 할 수 있음. `get`쓴다고 Map은 아니고 Map비스무리한 iterable임
    - request header는 `fetch`메소드에서 'headers'옵션을 쓰면 설정 가능
- `Response`의 `text`, `json`, `formData`등의 메소드를 이용해 response body를 얻을 수 있음
    - 해당 메소드들 중 하나만 쓸 수 있음. 텍스트로 얻고 싶어서 `text` 쓰고 다시 json형태로 얻고 싶어서 `json` 쓰고 이런거 불가능

### POST
- `fetch` 메소드 옵션 인자로 HTTP 메소드를 설정할 수 있음(설정 안하면 걍 'GET'임)
- request body로 뭘 보낼지(FormData, Blob, string(ex: JSON인코딩된 놈)..) 설정도 가능
    ```js
    let user = {
        name: 'John',
        surname: 'Smith'
    };
    let response = await fetch('/article/fetch/post/user', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json;charset=utf-8'
        },
        body: JSON.stringify(user)
    });
    let result = await response.json();
    console.log(result.message);
    ```
    - 참고로 request body를 위처럼 string으로 설정하면 header의 'Content-Type'은 'text/plain;charset=UTF-8'로 설정됨. 근데 우리는 JSON으로 보내려고 하니까 바꿔줘야.
    - request body에 따라 'Content-Type'의 기본값이 있는 덕분에 걍 설정 안하고 보내도 되는 경우가 있다.(이미지 Blob같은거 method/body만 설정해주고 걍 쏴버려도 됨)

## FormData
```js
let formData = new FormData([form]);
```
- HTML form 정보 보내는데 유용한 객체.
- `form`요소 인자로 넣으면 자동으로 내부 필드들 파악함
- `fetch`같은 네트워크용 메소드들의 request body로도 사용 가능하고, 이때 헤더는 'Content-Type'은  'multipart/form-data'
- 특정필드를 갖고 있는지 체크하거나(`has`) 해당 정보를 가져오는 메소드(`get`)도 있고 `append`로 필드 추가하고 해당하는 값/파일도 넣어 줄 수 있고 삭제(`delete`)도 가능함.
    - form에선 같은 필드 이름이 중복될 수도 있기 때문에 `form1.append('sameName', value)` 쓰면 덮어씌워지지 않고 추가됨.
    - `set`메소드는 `append`랑 사용법은 같은데, 얘는 같은 이름인 애들 싹 지우고 추가한 놈만 살려둠.

대충 예제 하나 보자
```html
<form id="formElem">
  <input type="text" name="firstName" value="John">
  Picture: <input type="file" name="picture" accept="image/*">
  <input type="submit">
</form>

<script>
  formElem.onsubmit = async (e) => {
    e.preventDefault();

    let response = await fetch('/article/formdata/post/user-avatar', {
      method: 'POST',
      body: new FormData(formElem)
    });

    let result = await response.json();

    alert(result.message);
  };
</script>
```

## Fetch: Download progress
- `fetch`로 다운로드 과정도 체크할 수 있음
    - `response.body`는 `response.text()`, `response.json()`같은 허접들과 달리 **ReadableStream**여서 chunk단위로 response body를 받아오고 이 과정을 확인 할 수 있음
- 업로드는 체크 못함. XMLHttpRequest ㄱㄱ
```js
// Step 1: fetch 시작 + reader 확보
let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits?per_page=100');

const reader = response.body.getReader();

// Step 2: 콘텐츠 총 길이 확인
const contentLength = +response.headers.get('Content-Length');

// Step 3: 데이터 읽기 시작
let receivedLength = 0; // 현 시점에 받은 bytes
let chunks = []; // body에서 받은 binary chunk들의 배열
while(true) {
    // done - true면 마지막 chunk
    // value - Uint8Array(byte 배열의 자료형이래)
	const {done, value} = await reader.read();

	if (done) {
		break;
	}

	chunks.push(value);
	receivedLength += value.length;

	console.log(`Received ${receivedLength} of ${contentLength}`)
}

// Step 4: 받은 데이터들을 하나의 Uint8Array로 합침
let chunksAll = new Uint8Array(receivedLength); // (4.1)
let position = 0;
for(let chunk of chunks) {
	chunksAll.set(chunk, position); // (4.2)
	position += chunk.length;
}

// Step 5: string으로 decode
let result = new TextDecoder("utf-8").decode(chunksAll);

let commits = JSON.parse(result);
alert(commits[0].author.login);
```

## Fetch: Abort
`fetch`는 promise를 반환하기 때문에 abort라는 개념이 없음. 근데 사용자가 요청했던 `fetch`가 더 이상 필요없는 경우도 있잖음? 이럴 때 built-in 객체 `AbortController` 씀. `fetch`말고 다른 비동기 작업에도 직빵임

사용법도 겁내 간단함
```js
let controller = new AbortController();
let signal = controller.signal;  // 이벤트 리스너 사용을 위한 property

// 취소될만한 작업을 하는 쪽에선 이렇게 signal에 이벤트 리스너 걸어둠
signal.addEventListener('abort', () => alert("abort!"));

// 실제로 작업을 취소시켜버리는 쪽에선 abort 메소드 호출
controller.abort(); // abort!

// abort메소드 호출시, signal에 abort이벤트 발생하고, singnal.aborted는 true됨
alert(signal.aborted); // true
```

### fetch에 써먹기
```js
let controller = new AbortController();
setTimeout(() => controller.abort(), 1000);

try {
	// fetch의 옵션에 signal 설정해주면 끝
	let response = await fetch('/article/fetch-abort/demo/hang', {
		signal: controller.signal
	});
} catch(err) {
	if (err.name == 'AbortError') { // abort()호출시 나오는 에러
		alert("Aborted!");
	} else {
		throw err;
  	}
}
```
참고로 `AbortController`는 여러 비동기 작업들을 한방에 취소시킬 수 있음(scalable)
```js
let urls = [...];
let controller = new AbortController();

let ourJob = new Promise((resolve, reject) => { // our task
	...
	controller.signal.addEventListener('abort', reject);
});

let fetchJobs = urls.map(url => fetch(url, { // fetches
	signal: controller.signal
}));

// 모든 fetch, 비동기 작업이 끝나길 기다림
// 만약 controller.abort() 이와중에 어디서 불린다? 싹다 abort됨
let results = await Promise.all([...fetchJobs, ourJob]);
```

## CORS
도메인이나 서브도메인, 프로토콜, 포트가 다른 곳에 요청을 보내는 것을 **Cross-Origin Request**라고 하며 이런 요청을 보내려면 remote origin에서 전송받은 특별한 헤더가 필요함.

이러한 정책을 CORS(Cross-Origin Resource Sharing)라고 함.

### 왜 필요한지, 그리고 꼼수들
- 타 사이트에 접근을 막음으로 해커에 대한 방어를 할 수 있었음
- 근데 옛날에는 네트워크 요청하는 메소드도 없어서 이런 제약을 우회하는 꼼수들을 쓰기 시작함
	- `<form>`과 `<iframe>` 사용하기. 자세한건 모르겠음
	- `<script>`의 `src`속성이 도메인 제약이 없는 부분을 이용하기<br>
	`<script src="http://another.com/…">`로 another.com에 데이터 요청하면 'JSONP'(JSON with padding)라는 프로토콜로 데이터를 가져옴. 대충 날씨 정보라고 치고.
		1. 서버에서 받은 데이터를 처리할 전역함수(`gotWeather`)선언
			```js
			function gotWeather({ temperature, humidity }) {
				alert(`temperature: ${temperature}, humidity: ${humidity}`);
			}
			```
		2. 전역함수를 URL매개변수 callback 값으로 쓰는 `<script src="http://another.com/weather.json?callback=gotWeather">`생성
			```js
				let script = document.createElement('script');
				script.src = `http://another.com/weather.json?callback=gotWeather`;
				document.body.append(script);
			```
		3. 'another.com'은 우리가 원하는 데이터를 인자로 받는 `gotWeather` 호출하는 스크립트를 동적으로 생성함
			```js
			// The expected answer from the server looks like this:
			gotWeather({
				temperature: 25,
				humidity: 78
			});
			```
		4. 'another.com'에서 스크립트가 실행되면 `gotWeather`함수가 실행되고, 이건 우리 함수니까 데이터도 받아 올 수 있음.<br>양쪽 모두 이런식으로 데이터 주고받기로 동의했으니 해킹 아님. 구식 브라우저에서 이게 먹혀서 아직 쓰는 사이트들도 있다고 함
	- 아무튼 이렇게 cross-origin request들이 필요하다 => CORS

### 안전한 요청(safe requests)
cross-origin request에는 2가지 타입이 있음
1. 안전한 요청
2. 나머지

안전한 요청은 2가지 요건을 만족시키면 됨.
1. [안전한 메소드](https://fetch.spec.whatwg.org/#cors-safelisted-method) - GET, POST, HEAD를 사용한 요청('PUT', 'DELETE' 이런애들도 안전한거 아님)
2. [안전한 헤더](https://fetch.spec.whatwg.org/#cors-safelisted-request-header) - 다음 목록에 속하는 헤더
	- 'Accept'
	- 'Accept-Language'
	- 'Content-Language'
	-  값이 application/x-www-form-urlencoded이나 multipart/form-data, text/plain인 'Content-Type'

안전하냐 아니냐의 근본적인 차이는 특별한 방법 없이 `<form>`, `<script>`를 사용해 요청을 만들 수 있다는거임. 오래된 웹서버도 안전한 요청은 당연히 처리 가능함.

옛날에는 안전하지 못한 요청이 웹페이지가 아니라 특별한 곳에서 왔을거라 해석하고 접근권한을 확인했지만 요새는 개발자들도 이런 요청을 보낼 수 있기 때문에 브라우저에서 'preflight'요청을 먼저 전송해 서버가 cross-origin req를 받을 준비가 됬는지 확인. 서박 ㄴㄴ 하면 요청 전송 실패함

### CORS와 안전한 요청, 응답
- cross-origin req 보낼 때 브라우저는 req에 'Origin'이라는 헤더에 요청 보내는 사이트의 오리진(도메인, 프로토콜, 포트정보)를 적음
- 서버가 헤더 'Access-Control-Allow-Origin'에 요청한 사이트의 오리진을 같이 적어주거나 *를 보내면 성공
- 브라우저는 js와 서버사이에서 'Origin'이 제대로 적혔고 전송되었는지, 'Access-Control-Allow-Origin'가 있는지 확인하는 등 중재자 역할을 함.
- js는 안전한 응답 헤더로 분류된 헤더에만 접속 가능. 그 외에 접근하면 에러
	- 'Cache-Control', 'Content-Language', 'Content-Type', 'Expires', 'Last-Modified', 'Pragma'
	- 안전하지 않은 헤더에 접근하고 싶다면 서버에서 'Access-Control-Expose-Headers' 헤더 보내줘야.

### 안전하지 않은 요청
- 안전하지 않은 요청을 바로 보내면 서버는 브라우저가 보낸 요청이 아니라고 생각하니까 이런 상황을 피하고자 'preflight' 요청을 먼저 보내 권한이 있는지 확인함.
	- 'OPTIONS' 메소드를 사용하고 안전하지 않은 요청에서 사용하는 메소드/헤더 정보가 담긴 'Access-Control-Request-Method/Headers' 두 헤더를 포함함. 본문은 비어있음.
- 서버가 요청을 허용하기로 했다면 본문은 비어있고 코드가 200인 응답을 다음 헤더와 함께 전송
	- Access-Control-Allow-Origin – *이나 오리진
	- Access-Control-Allow-Methods – 허용된 메서드 정보
	- Access-Control-Allow-Headers – 허용된 헤더 목록
	- Access-Control-Max-Age – 퍼미션 체크 여부를 몇 초간 캐싱해 놓을지를 명시. 캐싱으로 브라우저는 일정 기간 동안 preflight 요청을 생략하고 안전하지 않은 요청 가능
- 서버 응답까지 받았으면 본격적인 네트워크 요청/응답이 진행됨
- preflight는 js로 관찰 불가능

### 자격 증명(Credentials)
- cross-origin req는 기본적으로 쿠키, HTTP 인증같은게 함께 전송되지 않음.
	- 영향력이 강해서 사용자 동의 없이 js로 민감정보에 접근이 가능
- 그래도 원한다면 `fetch` 옵션에 `credentials: "include"`를 추가하면 됨.
- 서버에서도 이걸 허용했다면 'Access-Control-Allow-Credentials: true'헤더를 추가해서 보냄
	- 참고로 Credentials이 함께 처리 될때는 Access-Control-Allow-Origin에 * 불가능. 정확한 오리진만 가능