# 이벤트 기초
## 브라우저 이벤트
- 속성으로 `<elem onclick="함수()>"` 넣는거나, 스크립트 `elem.onclick=()=>{...}` 하는거나 똑같음
    - 브라우저는 속성값을 함수 본문으로 하는 핸들러 함수를 만들기 때문에 이런 차이가 발생
- `elem.setAttribute('onclick', () => alert(1))`같이 `setAttribute`로 핸들러 등록하지마라. 속성은 문자열이라 함수도 문자열이 되버림

### addEventListener
- `on<event>`로 바로 때려박는건 하나의 핸들러만 등록할 수 있고, 다른거 등록하면 덮어씌워지는 문제가 있음
- `element.addEventListener(event, handler, [options]);`로 해결
    - `option`의 property
        - `once`: `true`가 되면 이벤트 트리거 될 때 리스너가 자동 삭제.
        - `capture`: 어느 단계에서 이벤트를 다뤄야하는지
        - `passive` : `true`면 리스너에서 지정한 함수가 `preventDefault()` 호출x
    - `option`을 객체 대신 `boolean`값으로 넣을 수도 있는데 그러면 `{capture: true/false}`랑 동일함.
- `removeEventListener`로 삭제
- 핸들러 함수 대신 핸들러 메소드를 갖는 객체를 전달해줘도 됨.
    ```js
        <button id="elem">클릭해 주세요.</button>

        <script>
            class Menu {
                handleEvent(event) {
                    // mousedown -> onMousedown
                    let method = 'on' + event.type[0].toUpperCase() + event.type.slice(1);
                    this[method](event);
                }

                onMousedown() {
                    elem.innerHTML = "마우스 버튼을 눌렀습니다.";
                }

                onMouseup() {
                    elem.innerHTML += " 그리고 버튼을 뗐습니다.";
                }
            }

            let menu = new Menu();
            elem.addEventListener('mousedown', menu);
            elem.addEventListener('mouseup', menu);
        </script>
    ```

### 이벤트 객체
- 이벤트 발생시 브라우저가 이벤트 객체를 만들어 핸들러에 전달
- property
    - `type`: 타입
    - `currentTarget`: 이벤트를 처리하는 요소. arrow function 쓰면 `this`랑 같음
    - `event.clientX / event.clientY`: 브라우저 화면 기준 상대 좌표


## 버블링과 캡처링
![DOM이벤트 흐름](https://ko.javascript.info/article/bubbling-and-capturing/eventflow.svg)
`event.eventPhase`로 현재 발생 중인 이벤트 흐름 phase 확인 가능.<br>
같은 요소, 같은 단계에서의 이벤트 리스너는 설정 순서대로 동작함.
### target phase
- 이벤트가 실제 `target`에 전달되는 단계
### 버블링
한 요소에서 이벤트 발생시, 핸들러 작동하고 이어서 부모와 조상들의요소의 핸들러가 순차적으로 작동함.
- 대부분 버블링되는데 `focus`같이 안되는 애도 있음
- `event.target` : 이벤트가 발생한 가장 안쪽 요소. 버블링이 진행되어도 변함x. 반면 `currentTarget`(or `this`)은 현재 핸들러 작동하는 요소
- `event.stopPropagation()`메소드로 버블링 중단은 가능. 다른 이벤트를 담당하는 핸들러들의 동작도 함께 막아주고 싶다면 `stopImmediatePropagation` 메소드 써라.
    - 근데 꼭 멈춰야할 상황이 아니라면 쓰지말자. 커스텀 이벤트 등을 활용해라

### 캡쳐링
이벤트가 최상위 조상에서 `target`요소까지 전파되는 단계
- `addEventListener`에서 `{captrue: true}`를 `option`인자로 넣어주면 캡쳐링 단계에서 동작
 
## event delegation
이벤트를 처리해야하는 요소마다 이벤트 리스너를 달아주는게 아니라 부모에서 버블링 받아서 처리하게 함.
### 장점
- 많은 핸들러 할당하지 않아도 되니 초기화도 단순해지고, 메모리도 절약
- 요소를 추가/제거시 핸들러 추가/제거 필요x
### 단점
- 이벤트 버블링이 반드시 필요
- 컨테이너 수준에 할당된 핸들러가 응답할 필요가 있는 이벤트든 아니든 모든 하위 요소의 이벤트에 응답해야해서 CPU작업 부하가 늘어날 수는 있다(다만, 크진 않다.)