# 프로토타입과 프로토타입 상속
## 프로토타입 상속
- 기존 기능의 확장을 위해 사용됨.
- 객체에는 `[[Prototype]]`이란 property가 숨겨져있음
    - 다른 객체(부모) 참조 or null. 다른 자료형은 무시됨
    - 해당 객체에서 찾는 정보가 없다면 이걸 타고 다른 객체로 가서 확인
    - 순환참조 불가능(에러)
    - 하나의 객체만 참조(=상속) 가능
    - 부모 property는 `Object.keys`로는 확인 불가. **enumerable**이 true면 `for...in`으로는 확인 가능
```js
let animal = {
  eats: true,
  walk() {
    alert("동물이 걷습니다.");
  },
  get strength() {
      // this는 객체.strength 앞에 호출한 객체다!!!!
      return this._strength;
  },
  set strength(value) {
      this._strength = value;
  },
  stomach: [],
  eat(food) {
    // 주의. 값 할당이 아니라서 stomach의 상태를 자식들이 모두 똑같이 참조하게 됨.
    this.stomach.push(food);
    // this.stomach = [...this.stomach, food]로 수정하면 될듯
  }
};
let rabbit = {
  jumps: true,
};
// __proto__ == [[Prototype]]의 getter / setter
// 요새는 Object.getPrototypeOf나 Object.setPrototypeOf 사용
rabbit.__proto__ = animal; // (*)

// animal의 eats를 rabbit에서도 확인 가능
alert( rabbit.eats ); // true (**)
rabbit.walk(); // 동물이 걷습니다.

rabbit.walk = () => alert('토끼 걷는다'); // animal의 함수를 가려버림
rabbit.strength = 10;   // animal의 setter 호출. 값은 독립적으로 보유.
```
주의) 부모 프로토타입에서 단순 값 할당이 아니라 배열에 `push`와 같은 작업을 한다면, 자식들 모두가 해당 상태를 공유한다.

## 생성자함수.prototype
- `new 함수1()`로 생성된 객체는 생성자인 **함수1**에서 설정된 `prototype` property를 보고 [[Prototype]]을 설정한다.
- `prototype` property는 new 연산자를 사용할 때만 사용되며 값이 변경된다고 이전에 생성된 객체들의 [[Prototype]]이 변경되지 않음
- `prototype` property는 모든 함수가 갖고 있으며 `constructor`라는 property를 갖고 있음
- `constructor`는 기본적으로 함수 자신을 가리킴
- `new`로 생성된 객체는 `[[Prototype]]`을 거쳐 `constructor`에 접근해 새로운 객체 생성 가능
    ```js
    function Rabbit(name) {
        this.name = name;
        alert(name);
    }

    let r1 = new Rabbit("토끼1");
    let r2 = new r1.constructor("토끼2");
    // js는 constructor 값을 보장x!!!!!!!!!!!
    Rabbit.prototype = {
        jumps: true
    };
    let r3 = new Rabbit("토끼3");
    rabbit.constructor === Rabbit; // false
    // 다시 만들어줘야 constructor 사용 가능
    Rabbit.prototype = {
        jumps: true,
        constructor: Rabbit
    };
    r3 = new Rabbit("토끼3");
    ```
- `prototype`은 걍 포인터로 봐도 될듯
```js
function Rabbit() {}
Rabbit.prototype = {
  eats: true
};

let rabbit = new Rabbit();
// Rabbit.prototype = {};            rabbit.eats => true
// Rabbit.prototype.eats = false;    rabbit.eats => false
// delete rabbit.eats;               rabbit.eats => true
// delete Rabbit.prototype.eats;     rabbit.eats => undefined
```
