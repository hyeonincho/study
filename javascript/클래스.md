# 클래스
## 클래스와 기본 문법
```js
// User 함새 생성. 실행시 constructor가 실행됨.
class User {
  constructor(name) { this.name = name; }
  // 메소드는 User.prototype에 저장.
  sayHi() { alert(this.name); }
}
```
- js에서 클래스의 타입은 함수
- 생성자 함수를 직접 만드는 것과는 다름
    1. `class`로 만들면 `[[IsClassConstructor]]: true`
        - `new`와 함께 사용되는지 확인(`new` 없이 쓰면 에러)
        - 클래스를 문자열로 형변환시 `class 클래스명 {...}` 형식의 문자열로 변환됨
    2. 내부 메소드는 non-enumerable
    3. 항상 `use strict`가 적용됨. 생성자 코드에 자동으로 적용.
- 함수처럼 NFE, 동적생성 가능
    ```js
    let User = class MyClass {
        sayHi() {
            alert(MyClass);
        }
    };

    new User().sayHi();

    let makeClass = (phrase) => class {sayHi() {alert(phrase);}}
    let myClass = makeClass('새클래스');
    new myClass().sayHi();
    ```
- getter / setter 여전히 사용가능
- [...]를 이용한 computed method name
    ```js
    class User {
        ['say' + 'Hi']() {
            alert("Hello");
        }
    }

    new User().sayHi();
   ```
- 클래스 필드
    - 개별 객체에만 저장되는 데이터 (`prototype`에 저장x)
        ```js
        class User {
            name = prompt("이름 입력.", "이름");
        }

        let user = new User();
        ```
    - arrow function으로 `this`를 객체에 바인딩하는 메소드를 구현할 수 도 있으나..
        ```js
        class Button {
            constructor(value) {
                this.value = value;
            }
            // 클래스 필드
            click = () => {
                alert(this.value);
            }
        }

        let button = new Button("안녕하세요.");
        setTimeout(button.click, 1000);
        ```
      `prototype`을 생성하지 않아 `클래스명.prototype.함수 `로 접근이 불가함<br>
      상속도 안되고, 테스트 케이스 작성시 `spyOn(class명.prototype, 'method명')`으로 mocking 불가능
    - 클래스 필드가 먼저 초기화되고 생성자 호출됨.(부모 클래스가 있으면 `super()` 실행 직후 초기화)

## 클래스 상속
![상속](https://ko.javascript.info/article/class-inheritance/animal-rabbit-extends.svg)
참고) `extends` 키워드 뒤에 클래스를 반환하는 `함수('함수 인자')`같은 표현식이 올 수도 있다.

### 생성자 오버라이딩
- 생성자 작성안하면 알아서 만들어서 부모 생성자 `super(...args)` 호출
- 생성자 작성시 `super`호출 안하면 에러
    - `this` 사용 전에 반드시 호출
    - 상속받은 클래스는 `[[ConstructorKind]]:"derived"` property가 생성됨.
    - 일반 클래스는 `new`+생성자 함수로 실행되면 빈객체가 만들어지고 `this`에 해당 객체를 할당하는데, 상속받은 클래스는 이 작업을 부모 클래스 생성자가 처리해주길 기대하기 때문에 `super` 안부르면 `this`가 될 객체가 안만들어짐

### 클래스 필드 오버라이딩
- 부모 클래스 클래스 필드는 생성자 실행 이전에 초기화되지만 자식 클래스는 **`super()` 실행 직후 초기화된다.**
- 필드 오버라이딩이 문제가 되는 상황이 발생하면 메서드나 getter/setter를 이용해라
```js
class Animal {
  name = 'animal'

  constructor() {
    this.showName();
  }

  showName() {
      alert(`test: ${this.name}`);
  }
}

class Rabbit extends Animal {
  name = 'rabbit';
 
  showName() {
    alert(`child test: ${this.name}`);
  }
}

new Animal(); // test: animal
// 클래스필드는 아직 초기화되지 않아 부모의 것을 사용함.
let r= new Rabbit(); // child test: animal
r.showName(); // child test: rabbit
```

### super 키워드와 [[HomeObject]]
- `super`는 단순히 `this`와 `__proto__`의 조합x
- literal 객체에서 `method()`형태로 정의돼야 사용 가능. `method: function()`일 경우 x
```js
let animal = {
  name: "동물",
  eat() {
    alert(`${this.name} 이/가 먹이를 먹습니다.`);
  }
};

let rabbit = {
  __proto__: animal,
  name: '토끼',
  eat() {
    this.__proto__.eat.call(this); // (*)
  }
};

let longEar = {
  __proto__: rabbit,
  name: '긴토끼',
  eat() {
    this.__proto__.eat.call(this); // (**)
  }
};

rabbit.eat(); // 토끼 이/가 먹이를 먹습니다.
longEar.eat(); // RangeError: Maximum call stack size exceeded
```
- 손자(`longEar`)가 할부지(`animal`)의 메소드를 사용하려는 경우
    - 모든 `this`는 `longEar`를 가리킴 -> `this.__proto__ === rabbit`
    - 부모(`rabbit`)의 `eat`메소드가 실행되면 다시 `rabbit`의 `eat`메소드를 호출하는 무한루프.
    - `this`, `__proto__`로는 어렵다

- **`[[HomeObject]]`**
    - 클래스, 객체의 메소드에 property로 해당 객체가 저장됨
    - `super`는 이를 통해 해당 함수가 어디 객체/클래스껀지 보고 부모 프로토타입과 메소드를 찾음
    ```js
    let animal = {
        sayHi() {
            console.log(`나는 동물입니다.`);
        }
    };

    let rabbit = {
        __proto__: animal,
        sayHi() {
            super.sayHi();
        }
        // sayHi: function() { super.sayHi() } 이렇게는 못부름.
    };

    let plant = {
        sayHi() {
            console.log("나는 식물입니다.");
        }
    };

    let tree = {
        __proto__: plant,
        sayHi: rabbit.sayHi // (*)
    };

    tree.sayHi();  // 나는 동물입니다.
    ```
    - `[[HomeObject]]`는 함수의 자유도를 파괴함. 위와 같이 `this`가 다른 객체일지라도 메소드가 객체를 기억하기 때문에 한 번 바인딩되면 변경되질 않음
    - 단, `super` 내부에서만 유효하기 때문에 `super`만 안쓰면 ㄱㅊ

## static
- `prototype`이 아닌 클래스 자체에 메소드 붙이기 가능(정적 메소드)
    - `this`는 클래스 생성자
    - `sort`용 메소드나 팩토리 패턴 등 다양한 활용 가능
- 일반 property에도 붙이기 가능(최근 추가된 스펙. 크롬에서만 동작할 수도)
- 상속 가능

    ![static상속](https://ko.javascript.info/article/static-properties-methods/animal-rabbit-static.svg)
    <br> `extends`키워드로 `Rabbit`클래스의 `[[Prototype]]`은 `Animal` 클래스를 가리킴.
    <br> 덕분에 `compare` 정적 메소드를 `Rabbit.compare()`로 호출 가능