# 클래스
## 클래스와 기본 문법
```js
// User 함새 생성. 실행시 constructor가 실행됨.
class User {
  constructor(name) { this.name = name; }
  // 메소드는 User.prototype에 저장.
  sayHi() { alert(this.name); }
}
```
- js에서 클래스의 타입은 함수
- 생성자 함수를 직접 만드는 것과는 다름
    1. `class`로 만들면 `[[IsClassConstructor]]: true`
        - `new`와 함께 사용되는지 확인(`new` 없이 쓰면 에러)
        - 클래스를 문자열로 형변환시 `class 클래스명 {...}` 형식의 문자열로 변환됨
    2. 내부 메소드는 non-enumerable
    3. 항상 `use strict`가 적용됨. 생성자 코드에 자동으로 적용.
- 함수처럼 NFE, 동적생성 가능
    ```js
    let User = class MyClass {
        sayHi() {
            alert(MyClass);
        }
    };

    new User().sayHi();

    let makeClass = (phrase) => class {sayHi() {alert(phrase);}}
    let myClass = makeClass('새클래스');
    new myClass().sayHi();
    ```
- getter / setter 여전히 사용가능
- [...]를 이용한 computed method name
    ```js
    class User {
        ['say' + 'Hi']() {
            alert("Hello");
        }
    }

    new User().sayHi();
   ```
- 클래스 필드
    - 개별 객체에만 저장되는 데이터 (`prototype`에 저장x)
        ```js
        class User {
            name = prompt("이름 입력.", "이름");
        }

        let user = new User();
        ```
    - arrow function으로 `this`를 객체에 바인딩하는 메소드를 구현할 수 도 있으나..
        ```js
        class Button {
            constructor(value) {
                this.value = value;
            }
            // 클래스 필드
            click = () => {
                alert(this.value);
            }
        }

        let button = new Button("안녕하세요.");
        setTimeout(button.click, 1000);
        ```
      `prototype`을 생성하지 않아 `클래스명.prototype.함수 `로 접근이 불가함<br>
      상속도 안되고, 테스트 케이스 작성시 `spyOn(class명.prototype, 'method명')`으로 mocking 불가능
    - 클래스 필드가 먼저 초기화되고 생성자 호출됨.(부모 클래스가 있으면 `super()` 실행 직후 초기화)